<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Simple Splatoon Clone TPS</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; user-select: none; }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #top-bar {
            display: flex;
            justify-content: space-between;
            padding: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }
        #center-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }
        #crosshair {
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px black;
        }
        #message {
            color: white;
            font-size: 40px;
            font-weight: bold;
            text-shadow: 3px 3px 0 #000;
            display: none;
            pointer-events: auto;
            cursor: pointer;
            background: rgba(0,0,0,0.5);
            padding: 20px;
            border-radius: 10px;
        }
        #start-screen {
            pointer-events: auto;
            background: rgba(0,0,0,0.7);
            padding: 40px;
            border-radius: 20px;
            color: white;
        }
        button {
            padding: 10px 20px;
            font-size: 20px;
            cursor: pointer;
            background: #ff0055;
            color: white;
            border: none;
            border-radius: 5px;
        }
    </style>
</head>
<body>

<div id="ui-container">
    <div id="top-bar">
        <div id="timer">Time: 3:00</div>
        <div id="score">Score (Paint): 0</div>
    </div>
    <div id="crosshair"></div>
    <div id="center-ui">
        <div id="start-screen">
            <h1>Splat TPS Prototype</h1>
            <p>移動: WASD | ジャンプ: SPACE | 視点: マウス</p>
            <p>射撃: クリック (地面を塗れ！敵を倒せ！)</p>
            <button id="start-btn">ゲームスタート</button>
        </div>
        <div id="message">GAME OVER<br>Click to Retry</div>
    </div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // --- 設定 ---
    const PLAYER_COLOR = 0x00FFFF; // シアン
    const ENEMY_COLOR = 0xFF0055;  // マゼンタ
    const INK_SIZE = 1.5;
    const GAME_DURATION = 180; // 秒 (3分)

    // --- グローバル変数 ---
    let camera, scene, renderer, controls;
    let playerMesh, playerBody;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let prevTime = performance.now();
    
    let bullets = [];
    let enemies = [];
    let inks = [];
    let score = 0;
    let timeLeft = GAME_DURATION;
    let gameActive = false;
    let enemySpawnInterval;
    let timerInterval;

    const domTimer = document.getElementById('timer');
    const domScore = document.getElementById('score');
    const domMessage = document.getElementById('message');
    const domStartScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-btn');

    init();
    animate();

    function init() {
        // シーン設定
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff);
        scene.fog = new THREE.Fog(0x88ccff, 0, 70);

        // カメラ設定 (TPS風にするためプレイヤーの後ろに配置するが、ControlsはFPSベースを使うテクニック)
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 2; // 初期の高さ

        // レンダラー設定
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // ライト
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444);
        hemiLight.position.set(0, 20, 0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 地面
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        floor.name = "floor";
        scene.add(floor);

        // 障害物
        createObstacle(5, 1, 5);
        createObstacle(-10, 1, -10);
        createObstacle(15, 2, -5);

        // プレイヤー (可視化用メッシュ)
        const playerGeo = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
        const playerMat = new THREE.MeshStandardMaterial({ color: PLAYER_COLOR });
        playerMesh = new THREE.Mesh(playerGeo, playerMat);
        playerMesh.position.y = 1;
        playerMesh.castShadow = true;
        scene.add(playerMesh);

        // 武器
        const gunGeo = new THREE.BoxGeometry(0.2, 0.2, 0.6);
        const gunMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const gun = new THREE.Mesh(gunGeo, gunMat);
        gun.position.set(0.3, 0.2, 0.5);
        playerMesh.add(gun);

        // コントロール
        controls = new PointerLockControls(camera, document.body);

        // イベントリスナー
        startBtn.addEventListener('click', () => {
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            if(!gameActive && timeLeft === GAME_DURATION) startGame();
            domStartScreen.style.display = 'none';
        });

        controls.addEventListener('unlock', () => {
            domStartScreen.style.display = 'block';
        });
        
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        document.addEventListener('mousedown', onMouseDown);
        domMessage.addEventListener('click', resetGame);

        window.addEventListener('resize', onWindowResize);
    }

    function createObstacle(x, y, z) {
        const geo = new THREE.BoxGeometry(4, y*2, 4);
        const mat = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(x, y, z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        mesh.name = "wall";
        scene.add(mesh);
    }

    function startGame() {
        gameActive = true;
        score = 0;
        timeLeft = GAME_DURATION;
        updateUI();
        
        // 敵のスポーン開始
        enemySpawnInterval = setInterval(spawnEnemy, 3000);
        // タイマー開始
        timerInterval = setInterval(() => {
            timeLeft--;
            updateUI();
            if(timeLeft <= 0) endGame("Time's Up! Win!");
        }, 1000);
    }

    function endGame(msg) {
        gameActive = false;
        clearInterval(enemySpawnInterval);
        clearInterval(timerInterval);
        controls.unlock();
        domMessage.innerHTML = `${msg}<br>Score: ${score}<br><span style="font-size:20px">Click to Restart</span>`;
        domMessage.style.display = 'block';
        domStartScreen.style.display = 'none';
    }

    function resetGame() {
        // リセット処理
        location.reload(); 
    }

    function spawnEnemy() {
        if(!gameActive) return;
        
        // プレイヤーからある程度離れたランダムな位置
        const angle = Math.random() * Math.PI * 2;
        const radius = 20 + Math.random() * 20;
        const x = playerMesh.position.x + Math.cos(angle) * radius;
        const z = playerMesh.position.z + Math.sin(angle) * radius;

        const geo = new THREE.BoxGeometry(1, 1, 1);
        const mat = new THREE.MeshStandardMaterial({ color: ENEMY_COLOR });
        const enemy = new THREE.Mesh(geo, mat);
        enemy.position.set(x, 0.5, z);
        enemy.castShadow = true;
        enemy.receiveShadow = true;
        
        // 敵のステータス
        enemy.userData = { hp: 3, speed: 3 };
        
        scene.add(enemy);
        enemies.push(enemy);
    }

    function onKeyDown(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': moveForward = true; break;
            case 'ArrowLeft':
            case 'KeyA': moveLeft = true; break;
            case 'ArrowDown':
            case 'KeyS': moveBackward = true; break;
            case 'ArrowRight':
            case 'KeyD': moveRight = true; break;
            case 'Space': if (canJump === true) velocity.y += 15; canJump = false; break;
        }
    }

    function onKeyUp(event) {
        switch (event.code) {
            case 'ArrowUp':
            case 'KeyW': moveForward = false; break;
            case 'ArrowLeft':
            case 'KeyA': moveLeft = false; break;
            case 'ArrowDown':
            case 'KeyS': moveBackward = false; break;
            case 'ArrowRight':
            case 'KeyD': moveRight = false; break;
        }
    }

    function onMouseDown(event) {
        if (!gameActive || !controls.isLocked) return;
        
        // インク弾発射
        const bulletGeo = new THREE.SphereGeometry(0.2);
        const bulletMat = new THREE.MeshBasicMaterial({ color: PLAYER_COLOR });
        const bullet = new THREE.Mesh(bulletGeo, bulletMat);
        
        // プレイヤーの位置からカメラの向いている方向へ発射
        // 正確にはプレイヤーメッシュの武器の位置から
        bullet.position.copy(playerMesh.position);
        bullet.position.y += 0.5; // 目の高さ付近
        
        // 発射方向（カメラの向き）
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        
        bullet.userData = { velocity: dir.multiplyScalar(30), life: 100 }; // 速度
        
        scene.add(bullet);
        bullets.push(bullet);
    }

    function updateUI() {
        const m = Math.floor(timeLeft / 60);
        const s = timeLeft % 60;
        domTimer.innerText = `Time: ${m}:${s.toString().padStart(2, '0')}`;
        domScore.innerText = `Score (Paint): ${score}`;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();
        const delta = (time - prevTime) / 1000;

        if (controls.isLocked && gameActive) {
            // --- プレイヤー移動 ---
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 30.0 * delta; // 重力

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * 200.0 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 200.0 * delta;

            // 衝突判定（簡易版：床のみ）
            // カメラは実際の物理ボディではなく、プレイヤーメッシュを追従する
            // プレイヤーメッシュの位置更新
            
            // 仮の移動計算
            const moveX = -velocity.x * delta;
            const moveZ = -velocity.z * delta;

            // カメラの向きに合わせて移動ベクトルを回転
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const angle = Math.atan2(camDir.x, camDir.z);
            
            // 簡易的なTPS移動: プレイヤーの位置を更新
            playerMesh.translateX(velocity.x * delta);
            playerMesh.translateZ(velocity.z * delta);
            playerMesh.position.y += velocity.y * delta;

            // 床との衝突
            if (playerMesh.position.y < 1) {
                velocity.y = 0;
                playerMesh.position.y = 1;
                canJump = true;
            }
            
            // カメラをプレイヤーの後ろに配置 (TPS視点追従)
            // カメラの位置 = プレイヤーの位置 + オフセット
            // PointerLockControlsはカメラを直接回転させるため、
            // プレイヤーメッシュをカメラの前に固定するのではなく、
            // カメラの位置をプレイヤー基準で計算するが、今回はPointerLockの仕様上、
            // 「カメラ位置」を基準にプレイヤーメッシュを描画する方が挙動が安定する（FPS＋自分の体が見えるスタイル）
            
            // 修正: ControlsのObject（カメラ）を主体に移動させ、メッシュをそこに追従させる
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            camera.position.y += velocity.y * delta; // ジャンプ連動

             if (camera.position.y < 2) {
                velocity.y = 0;
                camera.position.y = 2;
                canJump = true;
            }
            
            // プレイヤーメッシュをカメラの前下方に配置
            // これで擬似的なTPSに見せる
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            forward.y = 0;
            forward.normalize();
            
            playerMesh.position.copy(camera.position);
            playerMesh.position.sub(forward.multiplyScalar(0.5)); // カメラより少し後ろへ（あるいは前へ）
            playerMesh.position.y -= 1.0; // 高さ調整
            
            // プレイヤーの回転をカメラに合わせる
            playerMesh.rotation.y = Math.atan2(forward.x, forward.z);
        }

        // --- 弾の更新 ---
        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.position.add(b.userData.velocity.clone().multiplyScalar(delta));
            b.userData.life--;

            // 地面との衝突 (y < 0)
            if (b.position.y <= 0.1) {
                paintFloor(b.position.x, b.position.z);
                scene.remove(b);
                bullets.splice(i, 1);
                continue;
            }

            // 壁/敵との衝突判定は簡易的に
            // 敵との判定
            let hitEnemy = false;
            for (let j = enemies.length - 1; j >= 0; j--) {
                const e = enemies[j];
                if (b.position.distanceTo(e.position) < 1.0) {
                    e.userData.hp--;
                    // ヒットエフェクトの代わりに少し大きく
                    e.scale.multiplyScalar(1.2);
                    setTimeout(() => e.scale.set(1,1,1), 100);

                    if (e.userData.hp <= 0) {
                        scene.remove(e);
                        enemies.splice(j, 1);
                        score += 50; // 敵撃破ボーナス
                    }
                    hitEnemy = true;
                    break;
                }
            }

            if (hitEnemy) {
                scene.remove(b);
                bullets.splice(i, 1);
            } else if (b.userData.life <= 0) {
                scene.remove(b);
                bullets.splice(i, 1);
            }
        }

        // --- 敵のAI (プレイヤー追跡) ---
        if (gameActive) {
            enemies.forEach(e => {
                const direction = new THREE.Vector3().subVectors(playerMesh.position, e.position).normalize();
                direction.y = 0; // 空中は飛ばない
                e.position.add(direction.multiplyScalar(e.userData.speed * delta));
                e.lookAt(playerMesh.position);

                // プレイヤーとの接触（ダメージ判定）
                if (e.position.distanceTo(playerMesh.position) < 1.0) {
                    endGame("DEFEATED by Enemy");
                }
            });
        }

        prevTime = time;https://github.com/queuegeforcenow/chatgpt-spatoon/edit/main/index.html
        renderer.render(scene, camera);
    }

    function paintFloor(x, z) {
        // インク（円盤）を生成して配置
        // パフォーマンスのため、本来はテクスチャ書き込みやデカールを使うが、
        // 簡易版として薄い円柱を置く
        const geo = new THREE.CircleGeometry(INK_SIZE, 16);
        const mat = new THREE.MeshBasicMaterial({ color: PLAYER_COLOR, depthTest: false, transparent: true, opacity: 0.8 });
        const ink = new THREE.Mesh(geo, mat);
        
        ink.position.set(x, 0.02, z); // 地面よりわずかに上
        ink.rotation.x = -Math.PI / 2;
        
        scene.add(ink);
        inks.push(ink);
        score += 10;
        updateUI();

        // 重なりすぎると重くなるので古いものを消す（簡易最適化）
        if (inks.length > 200) {
            const old = inks.shift();
            scene.remove(old);
        }
    }
</script>
</body>
</html>
