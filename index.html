<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Splatoon Clone V3 - Fixed Start</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; background: #222; }
        
        /* ゲーム内UI (HUD) */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* ゲーム操作を邪魔しない */
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #header {
            display: flex; justify-content: space-between; padding: 20px;
            font-size: 24px; font-weight: bold; color: white;
            text-shadow: 2px 2px 0 #000;
        }

        #status-panel {
            position: absolute; bottom: 30px; right: 30px;
            text-align: right; color: white; text-shadow: 1px 1px 2px black;
        }
        .gauge-container {
            margin-top: 5px; background: rgba(0,0,0,0.5);
            width: 200px; height: 15px; border: 2px solid white;
            border-radius: 10px; overflow: hidden;
        }
        .gauge-fill { height: 100%; transition: width 0.1s; }
        #ink-bar { background: #00FFFF; width: 100%; }
        #special-bar { background: linear-gradient(90deg, #ffcc00, #ff6600); width: 0%; }

        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
        }

        /* スタート画面 / リザルト画面 (最前面) */
        #overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: white;
            z-index: 9999; /* 確実に一番手前に */
            cursor: pointer; /* クリックできることを示す */
        }

        #loading-msg { color: #ff0055; font-size: 18px; max-width: 600px; text-align: center; margin-bottom: 20px; }
        
        button {
            margin-top: 20px; padding: 15px 50px;
            font-size: 24px; font-weight: bold;
            color: white; background: #ff0055;
            border: none; border-radius: 50px;
            pointer-events: none; /* 親divのクリックイベントで処理するため無効化 */
        }
        
        .key-guide {
            margin-top: 30px; font-size: 16px; line-height: 1.8;
            background: rgba(255,255,255,0.1); padding: 20px;
            border-radius: 10px; text-align: left;
            pointer-events: none;
        }
        .key { display: inline-block; background: #fff; color: #333; padding: 2px 6px; border-radius: 4px; font-weight: bold; margin: 0 4px; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="header">
        <div id="timer">Time: 3:00</div>
        <div id="score">Score: 0</div>
    </div>
    <div id="status-panel">
        <div>INK</div>
        <div class="gauge-container"><div id="ink-bar" class="gauge-fill"></div></div>
        <div style="margin-top:5px;">SPECIAL (Key: F)</div>
        <div class="gauge-container"><div id="special-bar" class="gauge-fill"></div></div>
    </div>
</div>

<div id="crosshair"></div>

<div id="overlay-screen">
    <div id="loading-msg">
        読み込み中...<br>
        (もしこの画面のまま止まる場合、Chromeなどがローカルファイルの実行をブロックしています。<br>
        EdgeまたはFirefoxで開くか、ローカルサーバー経由で実行してください。)
    </div>
    
    <h1 id="screen-title" style="display:none; font-size: 60px; margin: 0; text-shadow: 4px 4px 0 #ff0055;">SPLAT SHOOTER</h1>
    
    <div id="content-area" style="display:none; text-align:center;">
        <button id="start-btn">CLICK SCREEN TO START</button>
        <div class="key-guide">
            <div><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> 移動 | <span class="key">SPACE</span> ジャンプ</div>
            <div><span class="key">左クリック</span> インク発射</div>
            <div><span class="key">R</span> ボム (インク60%消費)</div>
            <div><span class="key">F</span> スーパー着地 (SPゲージMAX時)</div>
        </div>
    </div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // --- 読み込み成功時の処理 ---
    document.getElementById('loading-msg').style.display = 'none';
    document.getElementById('screen-title').style.display = 'block';
    document.getElementById('content-area').style.display = 'block';

    // --- 定数 ---
    const CONFIG = {
        PLAYER_COLOR: 0x00FFFF,
        ENEMY_COLOR: 0xFF0055,
        GAME_TIME: 180,
        GRAVITY: 30.0,
        INK_MAX: 100,
        INK_RECOVERY: 0.4,
        SPECIAL_MAX: 100
    };

    // --- 変数 ---
    let camera, scene, renderer, controls;
    let playerMesh;
    let gameState = {
        active: false,
        timeLeft: CONFIG.GAME_TIME,
        score: 0,
        ink: CONFIG.INK_MAX,
        special: 0
    };
    
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let prevTime = performance.now();
    
    const bullets = [];
    const enemies = [];
    const inks = [];
    const bombs = [];
    
    let isSuperLanding = false;
    let superLandingPhase = 0;
    
    // インターバル管理
    let timerInterval, enemyInterval;

    // DOM要素
    const ui = {
        overlay: document.getElementById('overlay-screen'),
        title: document.getElementById('screen-title'),
        btn: document.getElementById('start-btn'),
        timer: document.getElementById('timer'),
        score: document.getElementById('score'),
        inkBar: document.getElementById('ink-bar'),
        specialBar: document.getElementById('special-bar')
    };

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x88ccff);
        scene.fog = new THREE.Fog(0x88ccff, 10, 80);

        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 2;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // ライト
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.camera.right = 30;
        dirLight.shadow.camera.left = -30;
        dirLight.shadow.camera.top = 30;
        dirLight.shadow.camera.bottom = -30;
        scene.add(dirLight);

        // 地面
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.8 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // 障害物
        addBlock(5, 1.5, 5, 4, 3, 4);
        addBlock(-10, 2, -10, 6, 4, 6);
        addBlock(0, 3, -20, 20, 6, 2);

        // プレイヤー
        playerMesh = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.5, 1, 4, 8),
            new THREE.MeshStandardMaterial({ color: CONFIG.PLAYER_COLOR })
        );
        playerMesh.castShadow = true;
        scene.add(playerMesh);
        
        // 武器
        const gun = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.2, 0.6),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        gun.position.set(0.3, 0.3, 0.5);
        playerMesh.add(gun);

        // --- 重要: コントロール設定 ---
        controls = new PointerLockControls(camera, document.body);

        // 画面全体をクリックしたらスタートするように変更
        ui.overlay.addEventListener('click', () => {
            controls.lock();
        });

        controls.addEventListener('lock', () => {
            ui.overlay.style.display = 'none';
            if(!gameState.active && gameState.timeLeft === CONFIG.GAME_TIME) {
                startGame();
            } else if(!gameState.active && gameState.timeLeft > 0) {
                gameState.active = true; // ポーズ復帰
            }
        });

        controls.addEventListener('unlock', () => {
            if(gameState.timeLeft > 0) {
                gameState.active = false;
                ui.title.innerText = "PAUSED";
                ui.btn.innerText = "CLICK TO RESUME";
                ui.overlay.style.display = 'flex';
            }
        });

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        document.addEventListener('mousedown', onMouseDown);
        window.addEventListener('resize', onWindowResize);
    }

    function addBlock(x, y, z, w, h, d) {
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ color: 0x999999 }));
        mesh.position.set(x, y, z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
    }

    function startGame() {
        gameState.active = true;
        gameState.timeLeft = CONFIG.GAME_TIME;
        gameState.score = 0;
        gameState.ink = CONFIG.INK_MAX;
        gameState.special = 0;
        
        // 敵・インクのリセット
        enemies.forEach(e => scene.remove(e));
        enemies.length = 0;
        inks.forEach(i => scene.remove(i));
        inks.length = 0;
        
        // インターバル
        if(timerInterval) clearInterval(timerInterval);
        if(enemyInterval) clearInterval(enemyInterval);
        
        enemyInterval = setInterval(spawnEnemy, 2500);
        timerInterval = setInterval(() => {
            if(!gameState.active) return;
            gameState.timeLeft--;
            updateHUD();
            if(gameState.timeLeft <= 0) endGame(true);
        }, 1000);
    }

    function endGame(win) {
        gameState.active = false;
        controls.unlock();
        clearInterval(enemyInterval);
        clearInterval(timerInterval);
        
        ui.title.innerText = win ? "TIME UP!" : "GAME OVER";
        ui.btn.innerText = "CLICK TO RETRY";
        ui.score.innerText = `Final Score: ${gameState.score}`;
        ui.overlay.style.display = 'flex';
        
        // 次回のクリックでリロード
        ui.overlay.onclick = () => location.reload();
    }

    // --- 入力処理 ---
    function onKeyDown(e) {
        switch(e.code) {
            case 'KeyW': moveForward = true; break;
            case 'KeyA': moveLeft = true; break;
            case 'KeyS': moveBackward = true; break;
            case 'KeyD': moveRight = true; break;
            case 'Space': if(canJump && !isSuperLanding) { velocity.y += 15; canJump = false; } break;
            case 'KeyR': throwBomb(); break;
            case 'KeyF': triggerSpecial(); break;
        }
    }
    function onKeyUp(e) {
        switch(e.code) {
            case 'KeyW': moveForward = false; break;
            case 'KeyA': moveLeft = false; break;
            case 'KeyS': moveBackward = false; break;
            case 'KeyD': moveRight = false; break;
        }
    }
    function onMouseDown(e) {
        if(!gameState.active || !controls.isLocked) return;
        if(e.button === 0) shootInk();
    }

    // --- アクション ---
    function shootInk() {
        if(gameState.ink < 2) return;
        gameState.ink -= 2;
        
        const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({ color: CONFIG.PLAYER_COLOR }));
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        
        bullet.position.copy(playerMesh.position).add(new THREE.Vector3(0, 0.5, 0)).add(dir.clone().multiplyScalar(1));
        bullet.userData = { vel: dir.multiplyScalar(40), life: 60 };
        scene.add(bullet);
        bullets.push(bullet);
    }

    function throwBomb() {
        if(gameState.ink < 60) return;
        gameState.ink -= 60;
        
        const bomb = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.5, 4), new THREE.MeshStandardMaterial({ color: 0x008888, emissive: 0x004444 }));
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        
        bomb.position.copy(playerMesh.position).add(new THREE.Vector3(0, 1, 0)).add(dir.clone().multiplyScalar(0.5));
        
        const throwDir = dir.normalize();
        throwDir.y += 0.5;
        bomb.userData = { vel: throwDir.multiplyScalar(25), state: 'flying', timer: 0 };
        
        scene.add(bomb);
        bombs.push(bomb);
    }

    function triggerSpecial() {
        if(gameState.special < CONFIG.SPECIAL_MAX || isSuperLanding || !canJump) return;
        gameState.special = 0;
        isSuperLanding = true;
        superLandingPhase = 1;
        velocity.y = 50;
        canJump = false;
        playerMesh.material.emissive = new THREE.Color(0xFFFFFF);
    }

    function spawnEnemy() {
        if(!gameState.active) return;
        const angle = Math.random() * Math.PI * 2;
        const dist = 20 + Math.random() * 20;
        const enemy = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: CONFIG.ENEMY_COLOR }));
        enemy.position.set(playerMesh.position.x + Math.cos(angle)*dist, 0.5, playerMesh.position.z + Math.sin(angle)*dist);
        enemy.castShadow = true;
        enemy.userData = { hp: 3 };
        scene.add(enemy);
        enemies.push(enemy);
    }

    function createInk(x, z, size) {
        const ink = new THREE.Mesh(new THREE.CircleGeometry(size, 8), new THREE.MeshBasicMaterial({ color: CONFIG.PLAYER_COLOR, transparent: true, opacity: 0.8, depthTest: false }));
        ink.rotation.x = -Math.PI / 2;
        ink.position.set(x, 0.05, z);
        scene.add(ink);
        inks.push(ink);
        if(inks.length > 200) scene.remove(inks.shift());
        
        gameState.score += 10;
        if(gameState.special < CONFIG.SPECIAL_MAX) gameState.special += 2;
        updateHUD();
    }

    function explode(pos, radius) {
        const boom = new THREE.Mesh(new THREE.SphereGeometry(radius, 16, 16), new THREE.MeshBasicMaterial({ color: CONFIG.PLAYER_COLOR, transparent: true, opacity: 0.5 }));
        boom.position.copy(pos);
        scene.add(boom);
        setTimeout(() => scene.remove(boom), 150);
        
        for(let i=0; i<10; i++) {
            const a = Math.random() * Math.PI * 2;
            const d = Math.random() * radius;
            createInk(pos.x + Math.cos(a)*d, pos.z + Math.sin(a)*d, 2);
        }
        
        for(let i=enemies.length-1; i>=0; i--) {
            if(enemies[i].position.distanceTo(pos) < radius + 1) {
                scene.remove(enemies[i]);
                enemies.splice(i, 1);
                gameState.score += 100;
            }
        }
    }

    function updateHUD() {
        const m = Math.floor(gameState.timeLeft / 60);
        const s = gameState.timeLeft % 60;
        ui.timer.innerText = `Time: ${m}:${s.toString().padStart(2, '0')}`;
        ui.score.innerText = `Score: ${gameState.score}`;
        ui.inkBar.style.width = `${gameState.ink}%`;
        ui.specialBar.style.width = `${gameState.special}%`;
        
        ui.specialBar.parentElement.style.borderColor = gameState.special >= CONFIG.SPECIAL_MAX ? "#FFFF00" : "white";
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = performance.now();
        const delta = Math.min((time - prevTime) / 1000, 0.1);
        prevTime = time;

        if(!gameState.active) {
            renderer.render(scene, camera);
            return;
        }

        // インク回復
        if(gameState.ink < CONFIG.INK_MAX) gameState.ink += CONFIG.INK_RECOVERY;
        updateHUD();

        // 移動処理
        if(controls.isLocked) {
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= CONFIG.GRAVITY * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if(isSuperLanding) {
                if(superLandingPhase === 1 && velocity.y < 0) {
                    superLandingPhase = 2; velocity.y = 0;
                    setTimeout(() => { if(isSuperLanding) { superLandingPhase = 3; velocity.y = -100; } }, 300);
                }
            } else {
                if(moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if(moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;
            }

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            camera.position.y += velocity.y * delta;

            if(camera.position.y < 2) {
                if(isSuperLanding && superLandingPhase === 3) {
                    explode(playerMesh.position, 10);
                    isSuperLanding = false;
                    playerMesh.material.emissiveIntensity = 0;
                }
                velocity.y = 0; camera.position.y = 2; canJump = true;
            }
            
            // プレイヤー位置同期
            const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); camDir.y = 0; camDir.normalize();
            playerMesh.position.copy(camera.position).sub(camDir.multiplyScalar(0.5));
            playerMesh.position.y = 1; 
            playerMesh.rotation.y = Math.atan2(camDir.x, camDir.z);
        }

        // 弾処理
        for(let i=bullets.length-1; i>=0; i--) {
            const b = bullets[i];
            b.position.add(b.userData.vel.clone().multiplyScalar(delta));
            b.userData.vel.y -= 10 * delta; // 重力
            b.userData.life--;
            
            let hit = false;
            // 敵判定
            for(let j=enemies.length-1; j>=0; j--) {
                if(b.position.distanceTo(enemies[j].position) < 1) {
                    enemies[j].userData.hp--;
                    enemies[j].material.color.setHex(0xFFFFFF);
                    setTimeout(()=>enemies[j] && enemies[j].material.color.setHex(CONFIG.ENEMY_COLOR), 100);
                    if(enemies[j].userData.hp<=0) {
                        explode(enemies[j].position, 3);
                    }
                    hit = true; break;
                }
            }
            
            if(hit || b.position.y < 0.2 || b.userData.life <= 0) {
                if(b.position.y < 0.2) createInk(b.position.x, b.position.z, 1.5);
                scene.remove(b); bullets.splice(i, 1);
            }
        }

        // ボム処理
        for(let i=bombs.length-1; i>=0; i--) {
            const b = bombs[i];
            if(b.userData.state === 'flying') {
                b.position.add(b.userData.vel.clone().multiplyScalar(delta));
                b.userData.vel.y -= CONFIG.GRAVITY * delta;
                b.rotation.x += 10*delta;
                if(b.position.y < 0.2) {
                    b.position.y = 0.2; b.userData.state = 'waiting'; b.userData.vel.set(0,0,0);
                    b.material.emissive = new THREE.Color(0xFF0000);
                }
            } else {
                b.userData.timer += delta;
                if(b.userData.timer > 1.0) { explode(b.position, 6); scene.remove(b); bombs.splice(i, 1); }
            }
        }

        // 敵AI
        enemies.forEach(e => {
            const d = new THREE.Vector3().subVectors(playerMesh.position, e.position).normalize();
            d.y = 0;
            e.position.add(d.multiplyScalar(5 * delta)); // スピード
            e.lookAt(playerMesh.position);
            if(e.position.distanceTo(playerMesh.position) < 1 && !isSuperLanding) endGame(false);
        });

        renderer.render(scene, camera);
    }
</script>
</body>
</html>
